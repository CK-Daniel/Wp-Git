<?php
/**
 * Handles authentication logic for the GitHub API Client.
 * Manages different auth methods (PAT, OAuth, GitHub App) and token handling.
 *
 * @package WPGitHubSync\API
 */

namespace WPGitHubSync\API;

// If this file is called directly, abort.
if (!defined('WPINC')) {
    die;
}

/**
 * Authentication Manager class.
 */
class AuthManager {

    /**
     * The active authentication token.
     * @var string|null
     */
    private $token = null;

    /**
     * The configured authentication method ('pat', 'oauth', 'github_app').
     * @var string
     */
    private $auth_method = 'pat';

    /**
     * The determined token type ('fine_grained_pat', 'classic_pat', 'oauth', 'app_token', 'unknown').
     * @var string
     */
    private $token_type = 'unknown';

    /**
     * The preferred authorization format ('bearer' or 'token').
     * @var string
     */
    private $auth_format_preference = 'bearer'; // Default to Bearer as recommended by GitHub

    /**
     * Constructor. Loads authentication settings.
     */
    public function __construct() {
        $this->load_auth_settings();
    }

    /**
     * Load authentication settings from WordPress options.
     * Decrypts tokens and determines the active token.
     */
    public function load_auth_settings() {
        $this->auth_method = get_option('wp_github_sync_auth_method', 'pat');
        $this->auth_format_preference = get_option('wp_github_sync_auth_format', 'bearer'); // Load preference or default to bearer
        $this->token = null; // Reset token before loading

        // Check for dev token first
        $dev_token = defined('WP_GITHUB_SYNC_DEV_TOKEN') ? WP_GITHUB_SYNC_DEV_TOKEN : '';
        if (!empty($dev_token)) {
            wp_github_sync_log("AuthManager: Using development token from environment variable", 'debug');
            $this->token = $dev_token;
        } else {
            // Load token based on auth method
            switch ($this->auth_method) {
                case 'pat':
                    $encrypted_token = get_option('wp_github_sync_access_token', '');
                    $this->token = $this->decrypt_token($encrypted_token, 'PAT');
                    break;
                case 'oauth':
                    $encrypted_token = get_option('wp_github_sync_oauth_token', '');
                    $this->token = $this->decrypt_token($encrypted_token, 'OAuth');
                    break;
                case 'github_app':
                    // GitHub App token is generated on demand, check cache
                    $this->token = get_transient('wp_github_sync_github_app_token');
                    if ($this->token) {
                        wp_github_sync_log("AuthManager: Using cached GitHub App token", 'debug');
                    } else {
                         wp_github_sync_log("AuthManager: No cached GitHub App token found, will generate when needed", 'debug');
                         // Token remains null, will be generated by get_auth_header()
                    }
                    break;
            }
        }

        // Determine token type if a token is loaded
        if ($this->token) {
            $this->determine_token_type();
        } else {
             wp_github_sync_log("AuthManager: No active token loaded for method '{$this->auth_method}'", 'warning');
        }
    }

    /**
     * Decrypts a stored token and handles potential errors.
     *
     * @param string $encrypted_token The encrypted token from options.
     * @param string $token_label     Label for logging (e.g., 'PAT', 'OAuth').
     * @return string|null Decrypted token or null on failure.
     */
    private function decrypt_token(string $encrypted_token, string $token_label): ?string {
        if (empty($encrypted_token)) {
            wp_github_sync_log("AuthManager: No {$token_label} token found in options", 'debug');
            return null;
        }

        $decrypted = wp_github_sync_decrypt($encrypted_token);
        if ($decrypted === false) {
            wp_github_sync_log("AuthManager: Failed to decrypt {$token_label} token, clearing invalid token", 'error');
            // Clear the invalid token option
            if ($token_label === 'PAT') update_option('wp_github_sync_access_token', '');
            if ($token_label === 'OAuth') update_option('wp_github_sync_oauth_token', '');
            // Consider adding an admin notice here or returning an error
            return null;
        }

        wp_github_sync_log("AuthManager: Successfully decrypted {$token_label} token", 'debug');
        return $decrypted;
    }

    /**
     * Determine the type of the loaded token based on prefix/format.
     */
    private function determine_token_type() {
        if (!$this->token) {
            $this->token_type = 'unknown';
            return;
        }

        if (strpos($this->token, 'github_pat_') === 0) $this->token_type = 'fine_grained_pat';
        elseif (strpos($this->token, 'ghp_') === 0) $this->token_type = 'classic_pat';
        elseif (strpos($this->token, 'gho_') === 0) $this->token_type = 'oauth';
        elseif (strpos($this->token, 'ghs_') === 0) $this->token_type = 'app_token'; // Installation token
        elseif (strlen($this->token) === 40 && ctype_xdigit($this->token)) $this->token_type = 'classic_pat_hex';
        else $this->token_type = 'unknown';

        wp_github_sync_log("AuthManager: Determined token type: {$this->token_type}", 'debug');
    }

    /**
     * Get the appropriate Authorization header string.
     * Generates GitHub App token if needed.
     *
     * @param bool $force_format Optional. Force 'bearer' or 'token'. Defaults to preferred/determined format.
     * @return string|\WP_Error Authorization header value (e.g., "Bearer xxx") or WP_Error if token unavailable.
     */
    public function get_auth_header(string $force_format = '') {
        // Generate GitHub App token if needed
        if ($this->auth_method === 'github_app' && empty($this->token)) {
            $generated_token = $this->generate_github_app_token();
            if (is_wp_error($generated_token)) {
                return $generated_token; // Return error if generation failed
            }
            $this->token = $generated_token;
            $this->determine_token_type(); // Re-determine type after generation
        }

        if (empty($this->token)) {
            return new \WP_Error('no_token_available', __('No authentication token is available.', 'wp-github-sync'));
        }

        $format_to_use = strtolower($force_format);

        if (empty($format_to_use)) {
            // Determine best format based on token type and preference
            if ($this->token_type === 'app_token' || $this->token_type === 'oauth' || $this->token_type === 'fine_grained_pat') {
                $format_to_use = 'bearer'; // These generally require Bearer
            } else {
                // For classic PATs or unknown, use the stored preference (defaulting to bearer)
                $format_to_use = $this->auth_format_preference;
            }
        }

        wp_github_sync_log("AuthManager: Using '{$format_to_use}' format for Authorization header.", 'debug');
        return ucfirst($format_to_use) . ' ' . $this->token;
    }

    /**
     * Get the currently active token.
     *
     * @return string|null
     */
    public function get_token(): ?string {
        // Regenerate app token if needed and not cached
         if ($this->auth_method === 'github_app' && empty($this->token)) {
             $generated_token = $this->generate_github_app_token();
             if (!is_wp_error($generated_token)) {
                 $this->token = $generated_token;
             } else {
                 return null; // Failed to generate
             }
         }
        return $this->token;
    }

    /**
     * Get the configured authentication method.
     *
     * @return string
     */
    public function get_auth_method(): string {
        return $this->auth_method;
    }

    /**
     * Get the determined token type.
     *
     * @return string
     */
    public function get_token_type(): string {
        return $this->token_type;
    }

    /**
     * Set the preferred auth format (used when a request succeeds with a non-default format).
     *
     * @param string $format 'bearer' or 'token'.
     */
    public function set_preferred_auth_format(string $format) {
        $format = strtolower($format);
        if (in_array($format, ['bearer', 'token'])) {
            $this->auth_format_preference = $format;
            update_option('wp_github_sync_auth_format', $format);
            wp_github_sync_log("AuthManager: Set preferred auth format to '{$format}'", 'info');
        }
    }

    /**
     * Set a temporary token for testing, bypassing stored settings.
     *
     * @param string $token The temporary token.
     */
    public function set_temporary_token(string $token) {
        if (!empty($token)) {
            $this->token = trim($token); // Clean the token
            $this->determine_token_type(); // Update type based on temp token
            wp_github_sync_log("AuthManager: Set temporary token (type: {$this->token_type})", 'debug');
        }
    }

    /**
     * Generate a GitHub App installation token.
     * Requires the firebase/php-jwt library.
     *
     * @return string|\WP_Error The installation token or WP_Error on failure.
     */
    private function generate_github_app_token() {
        // Get the GitHub App settings
        $app_id = get_option('wp_github_sync_github_app_id', '');
        $installation_id = get_option('wp_github_sync_github_app_installation_id', '');
        $encrypted_key = get_option('wp_github_sync_github_app_key', '');

        if (empty($app_id) || empty($installation_id) || empty($encrypted_key)) {
            return new \WP_Error('missing_github_app_config', __('GitHub App configuration is incomplete.', 'wp-github-sync'));
        }

        // Decrypt the private key
        $private_key = wp_github_sync_decrypt($encrypted_key);
        if ($private_key === false) {
            return new \WP_Error('invalid_key', __('Could not decrypt GitHub App private key.', 'wp-github-sync'));
        }

        // Generate JWT token
        try {
            // Ensure JWT library is available
            if (!class_exists('\Firebase\JWT\JWT')) {
                 // Attempt to load via composer
                 $autoload_path = WP_GITHUB_SYNC_DIR . 'vendor/autoload.php';
                 if (file_exists($autoload_path)) {
                     require_once $autoload_path;
                 }
                 if (!class_exists('\Firebase\JWT\JWT')) {
                     return new \WP_Error('missing_jwt_library', __('JWT library not found. Please run composer install.', 'wp-github-sync'));
                 }
            }

            $jwt_payload = [
                'iat' => time() - 60, // Issued 60s in the past for clock skew
                'exp' => time() + (10 * 60) - 60, // Expires 9 minutes in the future (max 10 min)
                'iss' => $app_id
            ];

            $jwt = \Firebase\JWT\JWT::encode($jwt_payload, $private_key, 'RS256');

            // Use JWT to request an installation token
            $url = 'https://api.github.com/app/installations/' . $installation_id . '/access_tokens';
            $args = [
                'method' => 'POST',
                'headers' => [
                    'Accept' => 'application/vnd.github+json',
                    'Authorization' => 'Bearer ' . $jwt,
                    'User-Agent' => 'WordPress-GitHub-Sync/' . WP_GITHUB_SYNC_VERSION,
                    'X-GitHub-Api-Version' => '2022-11-28', // Use consistent API version
                ],
                'timeout' => 30,
            ];

            wp_github_sync_log('Requesting GitHub App installation token', 'debug');
            $response = wp_remote_request($url, $args);

            if (is_wp_error($response)) {
                wp_github_sync_log('Error requesting GitHub App token: ' . $response->get_error_message(), 'error');
                return $response;
            }

            $response_code = wp_remote_retrieve_response_code($response);
            $response_body = wp_remote_retrieve_body($response);
            $response_data = json_decode($response_body, true);

            if ($response_code !== 201 || !isset($response_data['token'])) {
                $error_message = isset($response_data['message']) ? $response_data['message'] : 'Unknown error generating app token';
                wp_github_sync_log('GitHub App token request failed: ' . $error_message, 'error');
                return new \WP_Error('github_app_token_failed', $error_message);
            }

            // Cache the token
            $token = $response_data['token'];
            $expires_at = isset($response_data['expires_at']) ? strtotime($response_data['expires_at']) : (time() + 3600);
            $cache_time = max(60, $expires_at - time() - 60); // Cache for slightly less than expiry, min 60s

            set_transient('wp_github_sync_github_app_token', $token, $cache_time);
            wp_github_sync_log('Successfully generated GitHub App token, valid until ' . date('Y-m-d H:i:s', $expires_at), 'debug');

            return $token;

        } catch (\Exception $e) {
            wp_github_sync_log('Exception generating GitHub App token: ' . $e->getMessage(), 'error');
            return new \WP_Error('github_app_token_exception', $e->getMessage());
        }
    }

} // End class AuthManager
